import glob
import io
import itertools
import json
import logging
import os
import re
import stat
import subprocess
from collections import namedtuple

from django.conf import settings

from tldextract import extract

from mobsf.MobSF.utils import (
    append_scan_status,
    find_java_binary,
    is_file_exists,
    is_internet_available,
    update_local_db,
)

logger = logging.getLogger(__name__)


class Trackers:
    def __init__(self, checksum, apk_dir, tools_dir):
        self.checksum = checksum
        self.apk = None
        self.apk_dir = apk_dir
        self.tracker_db = os.path.join(
            settings.SIGNATURE_DIR,
            'exodus_trackers')
        self.signatures = None
        self.nb_trackers_signature = 0
        self.compiled_tracker_signature = None
        self.compiled_network_tracker_sig = None
        self.classes = None
        self.tools_dir = tools_dir
        self._update_tracker_db()

    def _update_tracker_db(self):
        """更新追踪器数据库。"""
        try:
            if not is_internet_available():
                logger.warning('没有互联网连接。'
                               '跳过追踪器数据库更新。')
                return
            exodus_db = '{}/api/trackers'.format(settings.EXODUS_URL)
            resp = update_local_db('Trackers',
                                   exodus_db,
                                   self.tracker_db)
            # 检查1：SHA256变更
            if resp:
                # 数据库需要更新
                # 检查2：数据库语法变更
                data = json.loads(resp.decode('utf-8', 'ignore'))
                is_db_format_good = False
                if 'trackers' in data:
                    if '1' in data['trackers']:
                        if 'code_signature' in data['trackers']['1']:
                            is_db_format_good = True
                if is_db_format_good:
                    # 数据库格式未变更。让我们更新数据库
                    msg = '正在更新追踪器数据库....'
                    logger.info(msg)
                    append_scan_status(self.checksum, msg)
                    with open(self.tracker_db, 'wb') as wfp:
                        wfp.write(resp)
                else:
                    desc = (
                        '来自reports.exodus-privacy.eu.org的追踪器数据库格式已更改。'
                        '数据库未更新。'
                        '请报告至：https://github.com/MobSF/'
                        'Mobile-Security-Framework-MobSF/issues'
                    )
                    logger.info(desc)
                    append_scan_status(
                        self.checksum,
                        '追踪器数据库格式已更改',
                        desc)
        except Exception as exp:
            msg = '[错误] 追踪器数据库更新'
            logger.exception(msg)
            append_scan_status(self.checksum, msg, repr(exp))

    def _compile_signatures(self):
        """
        编译签名。

        编译与每个签名相关的正则表达式，以加速追踪器检测。
        :return: 已编译的签名列表。
        """
        self.compiled_tracker_signature = []
        self.compiled_network_tracker_sig = []
        try:
            self.compiled_tracker_signature = [
                re.compile(track.code_signature)
                for track in self.signatures]
            self.compiled_network_tracker_sig = [
                re.compile(track.network_signature)
                for track in self.signatures]
        except TypeError:
            logger.exception('编译追踪器签名失败')

    def load_trackers_signatures(self):
        """
        从官方Exodus数据库加载追踪器签名。

        :return: 签名字典。
        """
        self.signatures = []
        with io.open(self.tracker_db,
                     mode='r',
                     encoding='utf8',
                     errors='ignore') as flip:
            data = json.loads(flip.read())
        for elm in data['trackers']:
            self.signatures.append(
                namedtuple('tracker',
                           data['trackers'][elm].keys())(
                               *data['trackers'][elm].values()))
        self._compile_signatures()
        self.nb_trackers_signature = len(self.signatures)

    def get_embedded_classes(self):
        """
        获取所有DEX文件中的Java类列表。

        :return: Java类列表
        """
        if self.classes is not None:
            return self.classes
        for dex_file in glob.iglob(os.path.join(self.apk_dir, '*.dex')):
            # 修复dex权限，恶意软件将dex标记为不可读/写
            if not os.access(dex_file, os.W_OK):
                os.chmod(dex_file, stat.S_IWRITE)
            if not os.access(dex_file, os.R_OK):
                os.chmod(dex_file, stat.S_IREAD)
            if (len(settings.BACKSMALI_BINARY) > 0
                    and is_file_exists(settings.BACKSMALI_BINARY)):
                bs_path = settings.BACKSMALI_BINARY
            else:
                bs_path = os.path.join(self.tools_dir, 'baksmali-3.0.8-dev-fat.jar')
            args = [find_java_binary(), '-jar',
                    bs_path, 'list', 'classes', dex_file]
            try:
                classes = subprocess.check_output(
                    args, universal_newlines=True).splitlines()
                if self.classes is not None:
                    self.classes = self.classes + classes
                else:
                    self.classes = classes
            except Exception:
                pass
        return self.classes

    def detect_trackers_in_list(self, class_list, network=False):
        """
        在提供的类列表/URL中检测嵌入的追踪器。

        :return: 嵌入追踪器列表
        """
        if self.signatures is None:
            self.load_trackers_signatures()

        def _detect_tracker(sig, tracker, class_list):
            for clazz in class_list:
                if sig.search(clazz):
                    return tracker
            return None

        results = []
        if network:
            compiled = self.compiled_network_tracker_sig
            args = [
                (compiled[index], tracker, class_list)
                for (index, tracker) in enumerate(self.signatures) if
                len(tracker.network_signature) > 3]

        else:
            compiled = self.compiled_tracker_signature
            args = [
                (compiled[index], tracker, class_list)
                for (index, tracker) in enumerate(self.signatures) if
                len(tracker.code_signature) > 3]

        for res in itertools.starmap(_detect_tracker, args):
            if res:
                results.append(res)

        trackers = [t for t in results if t is not None]
        trackers = sorted(trackers, key=lambda trackers: trackers.name)
        return trackers

    def detect_trackers(self):
        """
        检测嵌入的追踪器。

        :return: 嵌入追踪器列表
        """
        if self.signatures is None:
            self.load_trackers_signatures()
        eclasses = self.get_embedded_classes()
        if eclasses:
            return self.detect_trackers_in_list(eclasses)
        return []

    def detect_runtime_trackers(self, items, deps=False):
        """
        检测运行时追踪器。

        :return: 嵌入追踪器列表
        """
        if self.signatures is None:
            self.load_trackers_signatures()
        if items and not deps:
            # 域名
            return self.detect_trackers_in_list(items, True)
        elif items and deps:
            # 运行时依赖
            return self.detect_trackers_in_list(items)
        return []

    def get_trackers(self):
        """获取追踪器。"""
        msg = '正在检测追踪器'
        logger.info(msg)
        append_scan_status(self.checksum, msg)
        trackers = self.detect_trackers()
        tracker_dict = {'detected_trackers': len(trackers),
                        'total_trackers': self.nb_trackers_signature,
                        'trackers': []}
        for trk in trackers:
            trk_url = '{}/trackers/{}'.format(settings.EXODUS_URL, trk.id)
            tracker_dict['trackers'].append({
                'name': trk.name,
                'categories': ', '.join(trk.categories),
                'url': trk_url,
            })
        return tracker_dict

    def get_trackers_domains_or_deps(self, domains, deps):
        """从运行时依赖/域名获取追踪器。"""
        trackers = []
        tracker_dict = {
            'detected_trackers': 0,
            'total_trackers': 0,
            'trackers': []}
        msg = '正在从域名检测追踪器'
        logger.info(msg)
        append_scan_status(self.checksum, msg)
        # 从域名提取追踪器
        x_domains = set()
        for d in domains:
            cps = extract(d)
            x_domains.add(f'{cps.domain}.{cps.suffix}')
        trackers = self.detect_runtime_trackers(x_domains)
        # 从运行时依赖提取追踪器
        if deps:
            msg = '正在从运行时依赖检测追踪器'
            logger.info(msg)
            append_scan_status(self.checksum, msg)
            runtime = self.detect_runtime_trackers(deps, True)
            for i in runtime:
                if i not in trackers:
                    trackers.append(i)
        tracker_dict['detected_trackers'] = len(trackers)
        tracker_dict['total_trackers'] = self.nb_trackers_signature
        for trk in trackers:
            trk_url = '{}/trackers/{}'.format(settings.EXODUS_URL, trk.id)
            tracker_dict['trackers'].append({
                'name': trk.name,
                'categories': ', '.join(trk.categories),
                'url': trk_url,
            })
        return tracker_dict